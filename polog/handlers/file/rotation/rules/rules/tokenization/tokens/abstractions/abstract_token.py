from polog.handlers.file.rotation.rules.rules.tokenization.tokens.abstractions.meta_token import MetaToken


class AbstractToken(metaclass=MetaToken):
    """
    Базовый класс, от которого должны быть унаследованы все токены.

    Исходная строка, подаваемая пользователем, бьется на токены.
    Токены не должны отличаться для вызывающего кода ничем, вызывающий код не должен как-то учитывать особенности реализации каждого конкретного токена.

    Разбиение текста на токены позволяет проверять его на соответствие определенным правилам. Скажем, можно проверять порядок последовательности токенов, не зная, что лежит в каждом из них.

    Каждый унаследованный класс токена должен гарантировать, что работает только с подстроками подходящей ему формы.
    """

    # Движок регулярных выражений использует данное поле для проверки соответствия последовательности определенным правилам.
    # В унаследованных классах здесь должна быть строка длиной ровно в 1 символ.
    # Символ '*' (звездочка), а также '[' и ']', зарезервированы для использования внутри движка регулярных выражений.
    # Соблюдение данных условий будет автоматически проверено на уровне метакласса.
    regexp_letter = None

    def __init__(self, source):
        """
        На вход подается некий кусок исходной строки.

        Мы делаем с ним 2 вещи:
        1. Проверяем, что он подходит для генерации данного типа токена. То есть, скажем, подстрока "ekfnjfn" вряд ли годится для преобразования в число, и проверку такого рода она пройти не должна.
        Если проверка не пройдена - поднимаем исключение. Вызывающий код должен рассматривать исключения, происходящие при инициализации объектов данного класса, как часть логики.
        2. Извлекаем из подстроки значение, которое кладем в self.content. Это может быть что угодно, в т. ч., скажем, кортеж.
        """
        self.source = source
        if not self.its_me(self.source):
            raise ValueError(f'The substring "{self.source}" is not valid for use to generate the {type(self).__name__}.')
        self.content = self.parse()

    def __repr__(self):
        name = self.__class__.__name__
        content = f'"{self.content}"' if type(self.content) is str else f'{self.content}'
        base = f'{name}({content})'
        return base

    def __eq__(self, other):
        """
        Токены можно проверять на равенство.
        Если другой токен того же класса и с тем же значением, что текущий, возвращается True, иначе False.
        """
        if self.__class__ is other.__class__:
            if self.content == other.content:
                return True
        return False

    @classmethod
    def its_me(cls, chunk):
        """
        Абстрактный метод.
        Проверка, что поданный кусок строки является валидным для преобразования в данный тип токенов.

        Возвращается bool по результатам проверки.
        """
        raise NotImplementedError() # pragma: no cover

    def parse(self):
        """
        Абстрактный метод.
        Здесь self.source преобразовывается в self.content.

        Возвращаемое значение может быть произвольного типа, в зависимости от природы токена. Скажем, для числа это может быть int, а для строки - str.
        """
        raise NotImplementedError() # pragma: no cover

    def equal(self, other_string):
        """
        Движок регулярных выражений позволяет проверять токен на точное соответствие какой-то подстроке.
        Если класс конкретного токена поддерживает такие сравнения, следует переопределить данный метод.
        По умолчанию результатом таких сравнений всегда будет False.
        """
        return False
