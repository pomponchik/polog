from polog.core.engine.real_engines.multithreaded.pool import ThreadPool
from polog.core.engine.real_engines.abstract import AbstractRealEngine


class MultiThreadedRealEngine(AbstractRealEngine):
    """
    Многопоточная реализация движка.

    Состоит из очереди, куда отправляются данные о событиях, и некоторого количества "воркеров", т. е. зацикленных функций в отдельных потоках, которые запрашивают новые события из очереди, и сразу обрабатывают их.
    Таким образом, каждый поток берет из очереди следующее событие сразу после того, как разобрался с предыдущим.

    Многопоточная реализация движка подразумевает 2 главных риска:
    1. Отсутствие гарантии правильной последовательности записи логов. Логи попадают в очередь обработки практически в правильном порядке, однако забирают их оттуда воркеры, каждый из которых может отрабатывать разное время, в результате чего запись логов в конкретное хранилище может осуществляться уже в неправильном порядке. Обычно это не имеет значения, однако стоит иметь ввиду.
    2. Возможность потери не успевших записаться логов в случае внештатного прекращения работы программы, например при внезапном отключении электричества. В этом случае те логи, которые все еще ждали своего часа в очереди, а также те, с которыми в тот момент работали обработчики, просто теряются. К сожалению, этот риск для асинхронных движков логирования непреодолим ввиду самого принципа их работы.

    Стоит отметить, что при штатном завершении программы все логи должны успеть записаться. Для этого через atexit регистрируется специальный обработчик, который следит, что программа будет завершена не раньше, чем очередь опустошится, и каждый из воркеров корректно завершит свою работу. Как уже было сказано, угроза потери данных актуальна только в случае нештатного прекращения работы программы - такого, как отключение питания компьютера.

    Кроме того, многопоточная реализация движка подразумевает некоторые дополнительные накладные расходы и в некоторых (очень редких) случаях може приводить к замедлению работы относительно синхронной реализации. Основные расходы:
    1. Создаются дополнительные потоки, а значит, появляются доп. накладные расходы на переключение между ними и работу GIL.
    2. Не успевшие записаться логи хранятся в очереди, то есть забирают часть оперативной памяти. В некоторых случаях, если логов пишется очень много, и обработчики не успевают их обрабатывать с той же скоростью, с какой они попадают в очередь, это может привести к переполнению памяти и остановке работы програаммы. Чтобы убрать этот риск, следует правильно подбирать нужное количество воркеров, желательно с запасом. Также можно установить лимит на максимальное число событий в очереди.

    При работе с многопоточным движком важно правильно выбирать нужное количество воркеров. Если их слишком много, большинство будет простаивать, отжирая вычислительную мощность. Если слишком мало, они не будут успевать обработать все логи в очереди. Выбирать количество воркеров нужно в том числе с учетом типа обработчиков. Некоторые обработчики - например те, что подолгу ожидают ответа сети - создают мало CPU-нагрузки, и в этом случае имеет смысл увеличить число воркеров.
    """

    def __init__(self, settings):
        super().__init__(settings)
        self.pool = ThreadPool(settings)

    def write(self, log_item):
        """
        Кладем аргументы оригинальной функции и извлеченные логгером данные в очередь на запись.
        """
        self.pool.put(log_item)

    def stop(self):
        self.pool.stop()

    def queue_size(self):
        """
        ПРИМЕРНЫЙ размер очереди, см. документацию:
        https://docs.python.org/3/library/queue.html#queue.Queue.qsize
        """
        return self.pool.queue.qsize()
