import pytest
from polog.handlers.file.base_formatter import BaseFormatter


def test_first_step_of_initialization():
    """
    Проверяем, что первичная инициализация объекта прошла успешно.
    А именно, что у объекта есть атрибут сепаратора, который мы передали аргументом.
    """
    formatter = BaseFormatter('kek')
    assert formatter.separator == 'kek'

def test_second_step_of_initialization():
    """
    Инициализация форматтера производится в два этапа.
    На первом (см. test_first_step_of_initialization()) сохраняются переданные пользователем параметры. Первый этап происходит при создании объекта.
    Второй этап - получение и сохранение различных динамических параметров. Это происходит непосредственно перед первой записью лога. Так сделано, поскольку при инициализации объекта могут быть еще неизвестны некоторые из динамических параметров форматтера. К примеру, ширина поля для записи уровней логирования зависит от длины самого длинного названия уровня логирования. Уровни логирования добавляются динамически в процессе выполнения программы и мы до самой первой записи лога не знаем, какие они будут (при этом существует договоренность, что все настройки логирования клиент обязан производить до первой записи лога, то есть мы можем быть уверены, что динамически это переписывать в дальнейшем не придется).

    Здесь мы проверяем, что:
    1. У объекта форматтера появляются новые атрибуты после первого вызова;
    2. Они не переопределяются при последующих вызовах;
    3. Они определены только на уровне экземпляра (т. к. у нас может быть несколько экземпляров обработчиков, которые используют по-разному настроенные форматтеры).
    """
    formatter = BaseFormatter('\n')
    assert not hasattr(formatter, 'FIELD_HANDLERS')
    assert not hasattr(formatter, 'ALIGN_NORMS')
    formatter.get_formatted_string((1, 2), **{'lol': 'lol', 'kek': 'kek'})
    assert hasattr(formatter, 'FIELD_HANDLERS')
    assert hasattr(formatter, 'ALIGN_NORMS')
    # Проверка, что второй шаг инициализации делается ровно один раз.
    # То есть что созданные атрибуты не переопределяются на каждом вызове метода .get_formatted_string().
    first_id = id(formatter.FIELD_HANDLERS)
    formatter.get_formatted_string((1, 2), **{'lol': 'lol', 'kek': 'kek'})
    assert first_id == id(formatter.FIELD_HANDLERS)
    # Проверяем, что новые атрибуты создались у экземпляра, а не у класса.
    # Для этого создаем новый экземпляр и проверяем, что их там снова нет.
    formatter = BaseFormatter('\n')
    assert not hasattr(formatter, 'FIELD_HANDLERS')
    assert not hasattr(formatter, 'ALIGN_NORMS')
